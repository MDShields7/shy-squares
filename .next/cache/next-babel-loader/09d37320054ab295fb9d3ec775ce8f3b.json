{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _mitt = _interopRequireDefault(require(\"../next-server/lib/mitt\"));\n\nvar _router = require(\"../next-server/lib/router/router\");\n\nvar _escapePathDelimiters = _interopRequireDefault(require(\"../next-server/lib/router/utils/escape-path-delimiters\"));\n\nvar _getAssetPathFromRoute = _interopRequireDefault(require(\"./../next-server/lib/router/utils/get-asset-path-from-route\"));\n\nvar _isDynamic = require(\"./../next-server/lib/router/utils/is-dynamic\");\n\nvar _parseRelativeUrl = require(\"./../next-server/lib/router/utils/parse-relative-url\");\n\nvar _querystring = require(\"./../next-server/lib/router/utils/querystring\");\n\nvar _routeMatcher = require(\"./../next-server/lib/router/utils/route-matcher\");\n\nvar _routeRegex = require(\"./../next-server/lib/router/utils/route-regex\");\n\nfunction hasRel(rel, link) {\n  try {\n    link = document.createElement('link');\n    return link.relList.supports(rel);\n  } catch (_unused) {}\n}\n\nfunction pageLoadError(route) {\n  return (0, _router.markLoadingError)(new Error(`Error loading ${route}`));\n}\n\nconst relPrefetch = hasRel('preload') && !hasRel('prefetch') ? // https://caniuse.com/#feat=link-rel-preload\n// macOS and iOS (Safari does not support prefetch)\n'preload' : // https://caniuse.com/#feat=link-rel-prefetch\n// IE 11, Edge 12+, nearly all evergreen\n'prefetch';\nconst hasNoModule = ('noModule' in document.createElement('script'));\n\nconst requestIdleCallback = window.requestIdleCallback || function (cb) {\n  return setTimeout(cb, 1);\n};\n/** @param {string} route */\n\n\nfunction normalizeRoute(route) {\n  if (route[0] !== '/') {\n    throw new Error(`Route name should start with a \"/\", got \"${route}\"`);\n  }\n\n  if (route === '/') return route;\n  return route.replace(/\\/$/, '');\n}\n\nfunction appendLink(href, rel, as) {\n  return new Promise((res, rej, link) => {\n    link = document.createElement('link');\n    link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    link.href = href;\n    link.rel = rel;\n    if (as) link.as = as;\n    link.onload = res;\n    link.onerror = rej;\n    document.head.appendChild(link);\n  });\n}\n\nclass PageLoader {\n  constructor(buildId, assetPrefix, initialPage) {\n    this.buildId = buildId;\n    this.assetPrefix = assetPrefix;\n    this.pageCache = {};\n    this.pageRegisterEvents = (0, _mitt.default)();\n    this.loadingRoutes = {\n      // By default these 2 pages are being loaded in the initial html\n      '/_app': true\n    }; // TODO: get rid of this limitation for rendering the error page\n\n    if (initialPage !== '/_error') {\n      this.loadingRoutes[initialPage] = true;\n    }\n\n    if (false) {\n      this.promisedBuildManifest = new Promise(resolve => {\n        if (window.__BUILD_MANIFEST) {\n          resolve(window.__BUILD_MANIFEST);\n        } else {\n          window.__BUILD_MANIFEST_CB = () => {\n            resolve(window.__BUILD_MANIFEST);\n          };\n        }\n      });\n    }\n    /** @type {Promise<Set<string>>} */\n\n\n    this.promisedSsgManifest = new Promise(resolve => {\n      if (window.__SSG_MANIFEST) {\n        resolve(window.__SSG_MANIFEST);\n      } else {\n        window.__SSG_MANIFEST_CB = () => {\n          resolve(window.__SSG_MANIFEST);\n        };\n      }\n    });\n  } // Returns a promise for the dependencies for a particular route\n\n\n  getDependencies(route) {\n    return this.promisedBuildManifest.then(m => {\n      var _this$pageRegisterEve;\n\n      return m[route] ? m[route].map(url => `${this.assetPrefix}/_next/${encodeURI(url)}`) : (_this$pageRegisterEve = this.pageRegisterEvents.emit(route, {\n        error: pageLoadError(route)\n      })) != null ? _this$pageRegisterEve : [];\n    });\n  }\n  /**\n  * @param {string} href the route href (file-system path)\n  * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n  */\n\n\n  getDataHref(href, asPath, ssg) {\n    const {\n      pathname: hrefPathname,\n      searchParams,\n      search\n    } = (0, _parseRelativeUrl.parseRelativeUrl)(href);\n    const query = (0, _querystring.searchParamsToUrlQuery)(searchParams);\n    const {\n      pathname: asPathname\n    } = (0, _parseRelativeUrl.parseRelativeUrl)(asPath);\n    const route = normalizeRoute(hrefPathname);\n\n    const getHrefForSlug =\n    /** @type string */\n    path => {\n      const dataRoute = (0, _getAssetPathFromRoute.default)(path, '.json');\n      return (0, _router.addBasePath)(`/_next/data/${this.buildId}${dataRoute}${ssg ? '' : search}`);\n    };\n\n    let isDynamic = (0, _isDynamic.isDynamicRoute)(route),\n        interpolatedRoute;\n\n    if (isDynamic) {\n      const dynamicRegex = (0, _routeRegex.getRouteRegex)(route);\n      const dynamicGroups = dynamicRegex.groups;\n      const dynamicMatches = // Try to match the dynamic route against the asPath\n      (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) || // Fall back to reading the values from the href\n      // TODO: should this take priority; also need to change in the router.\n      query;\n      interpolatedRoute = route;\n\n      if (!Object.keys(dynamicGroups).every(param => {\n        let value = dynamicMatches[param] || '';\n        const {\n          repeat,\n          optional\n        } = dynamicGroups[param]; // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n\n        let replaced = `[${repeat ? '...' : ''}${param}]`;\n\n        if (optional) {\n          replaced = `${!value ? '/' : ''}[${replaced}]`;\n        }\n\n        if (repeat && !Array.isArray(value)) value = [value];\n        return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present\n        interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(_escapePathDelimiters.default).join('/') : (0, _escapePathDelimiters.default)(value)) || '/');\n      })) {\n        interpolatedRoute = ''; // did not satisfy all requirements\n        // n.b. We ignore this error because we handle warning for this case in\n        // development in the `<Link>` component directly.\n      }\n    }\n\n    return isDynamic ? interpolatedRoute && getHrefForSlug(interpolatedRoute) : getHrefForSlug(route);\n  }\n  /**\n  * @param {string} href the route href (file-system path)\n  * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n  */\n\n\n  prefetchData(href, asPath) {\n    const {\n      pathname: hrefPathname\n    } = (0, _parseRelativeUrl.parseRelativeUrl)(href);\n    const route = normalizeRoute(hrefPathname);\n    return this.promisedSsgManifest.then((s, _dataHref) => {\n      requestIdleCallback(() => {\n        // Check if the route requires a data file\n        s.has(route) && ( // Try to generate data href, noop when falsy\n        _dataHref = this.getDataHref(href, asPath, true)) && // noop when data has already been prefetched (dedupe)\n        !document.querySelector(`link[rel=\"${relPrefetch}\"][href^=\"${_dataHref}\"]`) && // Inject the `<link rel=prefetch>` tag for above computed `href`.\n        appendLink(_dataHref, relPrefetch, 'fetch');\n      });\n    });\n  }\n\n  loadPage(route) {\n    route = normalizeRoute(route);\n    return new Promise((resolve, reject) => {\n      // If there's a cached version of the page, let's use it.\n      const cachedPage = this.pageCache[route];\n\n      if (cachedPage) {\n        const {\n          error,\n          page,\n          mod\n        } = cachedPage;\n        error ? reject(error) : resolve({\n          page,\n          mod\n        });\n        return;\n      }\n\n      const fire = ({\n        error,\n        page,\n        mod\n      }) => {\n        this.pageRegisterEvents.off(route, fire);\n        delete this.loadingRoutes[route];\n\n        if (error) {\n          reject(error);\n        } else {\n          resolve({\n            page,\n            mod\n          });\n        }\n      }; // Register a listener to get the page\n\n\n      this.pageRegisterEvents.on(route, fire);\n\n      if (!this.loadingRoutes[route]) {\n        this.loadingRoutes[route] = true;\n\n        if (false) {\n          this.getDependencies(route).then(deps => {\n            deps.forEach(d => {\n              if (d.endsWith('.js') && !document.querySelector(`script[src^=\"${d}\"]`)) {\n                this.loadScript(d, route);\n              }\n\n              if (d.endsWith('.css') && !document.querySelector(`link[rel=stylesheet][href^=\"${d}\"]`)) {\n                appendLink(d, 'stylesheet').catch(() => {// FIXME: handle failure\n                  // Right now, this is needed to prevent an unhandled rejection.\n                });\n              }\n            });\n          });\n        } else {\n          // Development only. In production the page file is part of the build manifest\n          route = normalizeRoute(route);\n          let scriptRoute = (0, _getAssetPathFromRoute.default)(route, '.js');\n          const url = `${this.assetPrefix}/_next/static/chunks/pages${encodeURI(scriptRoute)}`;\n          this.loadScript(url, route);\n        }\n      }\n    });\n  }\n\n  loadScript(url, route) {\n    const script = document.createElement('script');\n\n    if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n      script.type = 'module';\n    }\n\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    script.src = url;\n\n    script.onerror = () => {\n      this.pageRegisterEvents.emit(route, {\n        error: pageLoadError(url)\n      });\n    };\n\n    document.body.appendChild(script);\n  } // This method if called by the route code.\n\n\n  registerPage(route, regFn) {\n    const register = () => {\n      try {\n        const mod = regFn();\n        const pageData = {\n          page: mod.default || mod,\n          mod\n        };\n        this.pageCache[route] = pageData;\n        this.pageRegisterEvents.emit(route, pageData);\n      } catch (error) {\n        this.pageCache[route] = {\n          error\n        };\n        this.pageRegisterEvents.emit(route, {\n          error\n        });\n      }\n    };\n\n    if (true) {\n      // Wait for webpack to become idle if it's not.\n      // More info: https://github.com/vercel/next.js/pull/1511\n      if (module.hot && module.hot.status() !== 'idle') {\n        console.log(`Waiting for webpack to become \"idle\" to initialize the page: \"${route}\"`);\n\n        const check = status => {\n          if (status === 'idle') {\n            module.hot.removeStatusHandler(check);\n            register();\n          }\n        };\n\n        module.hot.status(check);\n        return;\n      }\n    }\n\n    register();\n  }\n  /**\n  * @param {string} route\n  * @param {boolean} [isDependency]\n  */\n\n\n  prefetch(route, isDependency) {\n    // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n    // License: Apache 2.0\n    let cn;\n\n    if (cn = navigator.connection) {\n      // Don't prefetch if using 2G or if Save-Data is enabled.\n      if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n    }\n    /** @type {string} */\n\n\n    let url;\n\n    if (isDependency) {\n      url = route;\n    } else {\n      if (true) {\n        route = normalizeRoute(route);\n        const ext = process.env.__NEXT_MODERN_BUILD && hasNoModule ? '.module.js' : '.js';\n        const scriptRoute = (0, _getAssetPathFromRoute.default)(route, ext);\n        url = `${this.assetPrefix}/_next/static/${encodeURIComponent(this.buildId)}/pages${encodeURI(scriptRoute)}`;\n      }\n    }\n\n    return Promise.all(document.querySelector(`link[rel=\"${relPrefetch}\"][href^=\"${url}\"]`) ? [] : [url && appendLink(url, relPrefetch, url.endsWith('.css') ? 'style' : 'script'), false && !isDependency && this.getDependencies(route).then(urls => Promise.all(urls.map(dependencyUrl => this.prefetch(dependencyUrl, true))))]).then( // do not return any data\n    () => {}, // swallow prefetch errors\n    () => {});\n  }\n\n}\n\nexports.default = PageLoader;","map":{"version":3,"sources":["../../client/page-loader.js"],"names":["link","document","route","relPrefetch","hasRel","hasNoModule","requestIdleCallback","window","setTimeout","process","PageLoader","constructor","initialPage","resolve","getDependencies","m","url","assetPrefix","encodeURI","error","pageLoadError","getDataHref","pathname","query","normalizeRoute","getHrefForSlug","path","dataRoute","buildId","ssg","search","isDynamic","dynamicRegex","dynamicGroups","dynamicMatches","interpolatedRoute","Object","param","value","replaced","repeat","Array","optional","escapePathDelimiters","prefetchData","s","_dataHref","appendLink","loadPage","cachedPage","reject","fire","deps","d","scriptRoute","loadScript","script","registerPage","register","mod","regFn","pageData","page","module","console","check","status","prefetch","cn","navigator","Promise","ext","encodeURIComponent","urls","dependencyUrl"],"mappings":";;;;;;;AAAA,IAAA,KAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,yBAAA,CAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,kCAAA,CAAA;;AACA,IAAA,qBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,wDAAA,CAAA,CAAA;;AACA,IAAA,sBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,6DAAA,CAAA,CAAA;;AACA,IAAA,UAAA,GAAA,OAAA,CAAA,8CAAA,CAAA;;AACA,IAAA,iBAAA,GAAA,OAAA,CAAA,sDAAA,CAAA;;AACA,IAAA,YAAA,GAAA,OAAA,CAAA,+CAAA,CAAA;;AACA,IAAA,aAAA,GAAA,OAAA,CAAA,iDAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,+CAAA,CAAA;;AAEA,SAAA,MAAA,CAAA,GAAA,EAAA,IAAA,EAA2B;AACzB,MAAI;AACFA,IAAAA,IAAI,GAAGC,QAAQ,CAARA,aAAAA,CAAPD,MAAOC,CAAPD;AACA,WAAOA,IAAI,CAAJA,OAAAA,CAAAA,QAAAA,CAAP,GAAOA,CAAP;AACA,GAHF,CAGE,OAAA,OAAA,EAAM,CACT;AAED;;AAAA,SAAA,aAAA,CAAA,KAAA,EAA8B;AAC5B,SAAO,CAAA,GAAA,OAAA,CAAA,gBAAA,EAAiB,IAAA,KAAA,CAAW,iBAAgBE,KAAnD,EAAwB,CAAjB,CAAP;AAGF;;AAAA,MAAMC,WAAW,GACf,MAAM,CAAN,SAAM,CAAN,IAAqB,CAACC,MAAM,CAA5B,UAA4B,CAA5B,GACI;AACA;AAFJ,SAAA,GAII;AACA;AANN,UAAA;AASA,MAAMC,WAAW,IAAG,cAAcJ,QAAQ,CAARA,aAAAA,CAAlC,QAAkCA,CAAjB,CAAjB;;AAEA,MAAMK,mBAAmB,GACvBC,MAAM,CAANA,mBAAAA,IACA,UAAA,EAAA,EAAc;AACZ,SAAOC,UAAU,CAAA,EAAA,EAAjB,CAAiB,CAAjB;AAHJ,CAAA;AAMA;;;AACA,SAAA,cAAA,CAAA,KAAA,EAA+B;AAC7B,MAAIN,KAAK,CAALA,CAAK,CAALA,KAAJ,GAAA,EAAsB;AACpB,UAAM,IAAA,KAAA,CAAW,4CAA2CA,KAA5D,GAAM,CAAN;AAGF;;AAAA,MAAIA,KAAK,KAAT,GAAA,EAAmB,OAAA,KAAA;AACnB,SAAOA,KAAK,CAALA,OAAAA,CAAAA,KAAAA,EAAP,EAAOA,CAAP;AAGF;;AAAA,SAAA,UAAA,CAAA,IAAA,EAAA,GAAA,EAAA,EAAA,EAAmC;AACjC,SAAO,IAAA,OAAA,CAAY,CAAA,GAAA,EAAA,GAAA,EAAA,IAAA,KAAoB;AACrCF,IAAAA,IAAI,GAAGC,QAAQ,CAARA,aAAAA,CAAPD,MAAOC,CAAPD;AACAA,IAAAA,IAAI,CAAJA,WAAAA,GAAmBS,OAAO,CAAPA,GAAAA,CAAnBT,mBAAAA;AACAA,IAAAA,IAAI,CAAJA,IAAAA,GAAAA,IAAAA;AACAA,IAAAA,IAAI,CAAJA,GAAAA,GAAAA,GAAAA;AACA,QAAA,EAAA,EAAQA,IAAI,CAAJA,EAAAA,GAAAA,EAAAA;AAERA,IAAAA,IAAI,CAAJA,MAAAA,GAAAA,GAAAA;AACAA,IAAAA,IAAI,CAAJA,OAAAA,GAAAA,GAAAA;AAEAC,IAAAA,QAAQ,CAARA,IAAAA,CAAAA,WAAAA,CAAAA,IAAAA;AAVF,GAAO,CAAP;AAca;;AAAA,MAAMS,UAAN,CAAiB;AAC9BC,EAAAA,WAAW,CAAA,OAAA,EAAA,WAAA,EAAA,WAAA,EAAoC;AAC7C,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,WAAA,GAAA,WAAA;AAEA,SAAA,SAAA,GAAA,EAAA;AACA,SAAA,kBAAA,GAA0B,CAAA,GAAA,KAAA,CAA1B,OAA0B,GAA1B;AACA,SAAA,aAAA,GAAqB;AACnB;AACA,eAFF;AAAqB,KAArB,CAN6C,CAW7C;;AACA,QAAIC,WAAW,KAAf,SAAA,EAA+B;AAC7B,WAAA,aAAA,CAAA,WAAA,IAAA,IAAA;AAGF;;AAAA,eAA2C;AACzC,WAAA,qBAAA,GAA6B,IAAA,OAAA,CAAaC,OAAD,IAAa;AACpD,YAAIN,MAAM,CAAV,gBAAA,EAA6B;AAC3BM,UAAAA,OAAO,CAACN,MAAM,CAAdM,gBAAO,CAAPA;AADF,SAAA,MAEO;AACLN,UAAAA,MAAM,CAANA,mBAAAA,GAA6B,MAAM;AACjCM,YAAAA,OAAO,CAACN,MAAM,CAAdM,gBAAO,CAAPA;AADFN,WAAAA;AAIH;AARD,OAA6B,CAA7B;AAUF;AAAA;;;AACA,SAAA,mBAAA,GAA2B,IAAA,OAAA,CAAaM,OAAD,IAAa;AAClD,UAAIN,MAAM,CAAV,cAAA,EAA2B;AACzBM,QAAAA,OAAO,CAACN,MAAM,CAAdM,cAAO,CAAPA;AADF,OAAA,MAEO;AACLN,QAAAA,MAAM,CAANA,iBAAAA,GAA2B,MAAM;AAC/BM,UAAAA,OAAO,CAACN,MAAM,CAAdM,cAAO,CAAPA;AADFN,SAAAA;AAIH;AARD,KAA2B,CAA3B;AAWF,GAxC8B,CAwC9B;;;AACAO,EAAAA,eAAe,CAAA,KAAA,EAAQ;AACrB,WAAO,KAAA,qBAAA,CAAA,IAAA,CAAiCC,CAAD,IAAO;AAAA,UAAA,qBAAA;;AAC5C,aAAOA,CAAC,CAADA,KAAC,CAADA,GACHA,CAAC,CAADA,KAAC,CAADA,CAAAA,GAAAA,CAAcC,GAAD,IAAU,GAAE,KAAKC,WAAY,UAASC,SAAS,CAAA,GAAA,CADzDH,EACHA,CADGA,GAAAA,CAAAA,qBAAAA,GAEH,KAAA,kBAAA,CAAA,IAAA,CAAA,KAAA,EAAoC;AAClCI,QAAAA,KAAK,EAAEC,aAAa,CAHnBL,KAGmB;AADc,OAApC,CAFGA,KAAAA,IAAAA,GAAAA,qBAAAA,GAAP,EAAA;AADF,KAAO,CAAP;AASF;AAAA;;;;;;AAIAM,EAAAA,WAAW,CAAA,IAAA,EAAA,MAAA,EAAA,GAAA,EAAoB;AAC7B,UAAM;AAAEC,MAAAA,QAAQ,EAAV,YAAA;AAAA,MAAA,YAAA;AAAA,MAAA;AAAA,QAAmD,CAAA,GAAA,iBAAA,CAAA,gBAAA,EAAzD,IAAyD,CAAzD;AAGA,UAAMC,KAAK,GAAG,CAAA,GAAA,YAAA,CAAA,sBAAA,EAAd,YAAc,CAAd;AACA,UAAM;AAAED,MAAAA,QAAQ,EAAV;AAAA,QAA2B,CAAA,GAAA,iBAAA,CAAA,gBAAA,EAAjC,MAAiC,CAAjC;AACA,UAAMpB,KAAK,GAAGsB,cAAc,CAA5B,YAA4B,CAA5B;;AAEA,UAAMC,cAAc;AAAI;AAAoBC,IAAAA,IAArB,IAA8B;AACnD,YAAMC,SAAS,GAAG,CAAA,GAAA,sBAAA,CAAA,OAAA,EAAA,IAAA,EAAlB,OAAkB,CAAlB;AACA,aAAO,CAAA,GAAA,OAAA,CAAA,WAAA,EACJ,eAAc,KAAKC,OAAQ,GAAED,SAAU,GAAEE,GAAG,GAAA,EAAA,GAAQC,MADvD,EAAO,CAAP;AAFF,KAAA;;AAOA,QAAIC,SAAS,GAAG,CAAA,GAAA,UAAA,CAAA,cAAA,EAAhB,KAAgB,CAAhB;AAAA,QAAA,iBAAA;;AAEA,QAAA,SAAA,EAAe;AACb,YAAMC,YAAY,GAAG,CAAA,GAAA,WAAA,CAAA,aAAA,EAArB,KAAqB,CAArB;AACA,YAAMC,aAAa,GAAGD,YAAY,CAAlC,MAAA;AACA,YAAME,cAAc,GAClB;AACA,OAAA,GAAA,aAAA,CAAA,eAAA,EAAA,YAAA,EAAA,UAAA,KACA;AACA;AAJF,MAAA,KAAA;AAOAC,MAAAA,iBAAiB,GAAjBA,KAAAA;;AACA,UACE,CAACC,MAAM,CAANA,IAAAA,CAAAA,aAAAA,EAAAA,KAAAA,CAAkCC,KAAD,IAAW;AAC3C,YAAIC,KAAK,GAAGJ,cAAc,CAAdA,KAAc,CAAdA,IAAZ,EAAA;AACA,cAAM;AAAA,UAAA,MAAA;AAAA,UAAA;AAAA,YAAuBD,aAAa,CAA1C,KAA0C,CAA1C,CAF2C,CAI3C;AACA;;AACA,YAAIM,QAAQ,GAAI,IAAGC,MAAM,GAAA,KAAA,GAAW,EAAG,GAAEH,KAAzC,GAAA;;AACA,YAAA,QAAA,EAAc;AACZE,UAAAA,QAAQ,GAAI,GAAE,CAAA,KAAA,GAAA,GAAA,GAAe,EAAG,IAAGA,QAAnCA,GAAAA;AAEF;;AAAA,YAAIC,MAAM,IAAI,CAACC,KAAK,CAALA,OAAAA,CAAf,KAAeA,CAAf,EAAqCH,KAAK,GAAG,CAARA,KAAQ,CAARA;AAErC,eACE,CAACI,QAAQ,IAAIL,KAAK,IAAlB,cAAA,OACA;AACCF,QAAAA,iBAAiB,GAChBA,iBAAiB,CAAjBA,OAAAA,CAAAA,QAAAA,EAEEK,MAAM,GACFF,KAAK,CAALA,GAAAA,CAAUK,qBAAAA,CAAVL,OAAAA,EAAAA,IAAAA,CADE,GACFA,CADE,GAEF,CAAA,GAAA,qBAAA,CAAA,OAAA,EAJNH,KAIM,CAJNA,KAJJ,GACE,CADF;AAbJ,OACGC,CADH,EAyBE;AACAD,QAAAA,iBAAiB,GAAjBA,EAAAA,CADA,CACuB;AAEvB;AACA;AAEH;AAED;;AAAA,WAAOJ,SAAS,GACZI,iBAAiB,IAAIV,cAAc,CADvB,iBACuB,CADvB,GAEZA,cAAc,CAFlB,KAEkB,CAFlB;AAKF;AAAA;;;;;;AAIAmB,EAAAA,YAAY,CAAA,IAAA,EAAA,MAAA,EAAe;AACzB,UAAM;AAAEtB,MAAAA,QAAQ,EAAV;AAAA,QAA6B,CAAA,GAAA,iBAAA,CAAA,gBAAA,EAAnC,IAAmC,CAAnC;AACA,UAAMpB,KAAK,GAAGsB,cAAc,CAA5B,YAA4B,CAA5B;AACA,WAAO,KAAA,mBAAA,CAAA,IAAA,CAA8B,CAAA,CAAA,EAAA,SAAA,KAAkB;AACrD,MAAA,mBAAmB,CAAC,MAAM;AACxB;AACAqB,QAAAA,CAAC,CAADA,GAAAA,CAAAA,KAAAA,OACE;AACCC,QAAAA,SAAS,GAAG,KAAA,WAAA,CAAA,IAAA,EAAA,MAAA,EAFfD,IAEe,CAFfA,KAGE;AACA,SAAC5C,QAAQ,CAARA,aAAAA,CACE,aAAYE,WAAY,aAAY2C,SALzCD,IAIG5C,CAJH4C,IAOE;AACAE,QAAAA,UAAU,CAAA,SAAA,EAAA,WAAA,EARZF,OAQY,CARZA;AAFF,OAAmB,CAAnB;AADF,KAAO,CAAP;AAgBFG;;AAAAA,EAAAA,QAAQ,CAAA,KAAA,EAAQ;AACd9C,IAAAA,KAAK,GAAGsB,cAAc,CAAtBtB,KAAsB,CAAtBA;AAEA,WAAO,IAAA,OAAA,CAAY,CAAA,OAAA,EAAA,MAAA,KAAqB;AACtC;AACA,YAAM+C,UAAU,GAAG,KAAA,SAAA,CAAnB,KAAmB,CAAnB;;AACA,UAAA,UAAA,EAAgB;AACd,cAAM;AAAA,UAAA,KAAA;AAAA,UAAA,IAAA;AAAA,UAAA;AAAA,YAAN,UAAA;AACA9B,QAAAA,KAAK,GAAG+B,MAAM,CAAT,KAAS,CAAT,GAAmBrC,OAAO,CAAC;AAAA,UAAA,IAAA;AAAhCM,UAAAA;AAAgC,SAAD,CAA/BA;AACA;AAGF;;AAAA,YAAMgC,IAAI,GAAG,CAAC;AAAA,QAAA,KAAA;AAAA,QAAA,IAAA;AAAD,QAAA;AAAC,OAAD,KAA0B;AACrC,aAAA,kBAAA,CAAA,GAAA,CAAA,KAAA,EAAA,IAAA;AACA,eAAO,KAAA,aAAA,CAAP,KAAO,CAAP;;AAEA,YAAA,KAAA,EAAW;AACTD,UAAAA,MAAM,CAANA,KAAM,CAANA;AADF,SAAA,MAEO;AACLrC,UAAAA,OAAO,CAAC;AAAA,YAAA,IAAA;AAARA,YAAAA;AAAQ,WAAD,CAAPA;AAEH;AATD,OAAA,CATsC,CAoBtC;;;AACA,WAAA,kBAAA,CAAA,EAAA,CAAA,KAAA,EAAA,IAAA;;AAEA,UAAI,CAAC,KAAA,aAAA,CAAL,KAAK,CAAL,EAAgC;AAC9B,aAAA,aAAA,CAAA,KAAA,IAAA,IAAA;;AACA,mBAA2C;AACzC,eAAA,eAAA,CAAA,KAAA,EAAA,IAAA,CAAkCuC,IAAD,IAAU;AACzC,YAAA,IAAI,CAAJ,OAAA,CAAcC,CAAD,IAAO;AAClB,kBACEA,CAAC,CAADA,QAAAA,CAAAA,KAAAA,KACA,CAACpD,QAAQ,CAARA,aAAAA,CAAwB,gBAAeoD,CAF1C,IAEGpD,CAFH,EAGE;AACA,qBAAA,UAAA,CAAA,CAAA,EAAA,KAAA;AAEF;;AAAA,kBACEoD,CAAC,CAADA,QAAAA,CAAAA,MAAAA,KACA,CAACpD,QAAQ,CAARA,aAAAA,CAAwB,+BAA8BoD,CAFzD,IAEGpD,CAFH,EAGE;AACA,gBAAA,UAAU,CAAA,CAAA,EAAV,YAAU,CAAV,CAAA,KAAA,CAAkC,MAAM,CACtC;AACA;AAFF,iBAAA;AAKH;AAhBD,aAAA;AADF,WAAA;AADF,SAAA,MAoBO;AACL;AACAC,UAAAA,KAAK,GAAGsB,cAAc,CAAtBtB,KAAsB,CAAtBA;AACA,cAAIoD,WAAW,GAAG,CAAA,GAAA,sBAAA,CAAA,OAAA,EAAA,KAAA,EAAlB,KAAkB,CAAlB;AAEA,gBAAMtC,GAAG,GAAI,GAAE,KAAKC,WAAY,6BAA4BC,SAAS,CAAA,WAAA,CAArE,EAAA;AAGA,eAAA,UAAA,CAAA,GAAA,EAAA,KAAA;AAEH;AACF;AAxDD,KAAO,CAAP;AA2DFqC;;AAAAA,EAAAA,UAAU,CAAA,GAAA,EAAA,KAAA,EAAa;AACrB,UAAMC,MAAM,GAAGvD,QAAQ,CAARA,aAAAA,CAAf,QAAeA,CAAf;;AACA,QAAIQ,OAAO,CAAPA,GAAAA,CAAAA,mBAAAA,IAAJ,WAAA,EAAoD;AAClD+C,MAAAA,MAAM,CAANA,IAAAA,GAAAA,QAAAA;AAEFA;;AAAAA,IAAAA,MAAM,CAANA,WAAAA,GAAqB/C,OAAO,CAAPA,GAAAA,CAArB+C,mBAAAA;AACAA,IAAAA,MAAM,CAANA,GAAAA,GAAAA,GAAAA;;AACAA,IAAAA,MAAM,CAANA,OAAAA,GAAiB,MAAM;AACrB,WAAA,kBAAA,CAAA,IAAA,CAAA,KAAA,EAAoC;AAAErC,QAAAA,KAAK,EAAEC,aAAa,CAA1D,GAA0D;AAAtB,OAApC;AADFoC,KAAAA;;AAGAvD,IAAAA,QAAQ,CAARA,IAAAA,CAAAA,WAAAA,CAAAA,MAAAA;AAGF,GA3N8B,CA2N9B;;;AACAwD,EAAAA,YAAY,CAAA,KAAA,EAAA,KAAA,EAAe;AACzB,UAAMC,QAAQ,GAAG,MAAM;AACrB,UAAI;AACF,cAAMC,GAAG,GAAGC,KAAZ,EAAA;AACA,cAAMC,QAAQ,GAAG;AAAEC,UAAAA,IAAI,EAAEH,GAAG,CAAHA,OAAAA,IAAR,GAAA;AAAjB,UAAA;AAAiB,SAAjB;AACA,aAAA,SAAA,CAAA,KAAA,IAAA,QAAA;AACA,aAAA,kBAAA,CAAA,IAAA,CAAA,KAAA,EAAA,QAAA;AACA,OALF,CAKE,OAAA,KAAA,EAAc;AACd,aAAA,SAAA,CAAA,KAAA,IAAwB;AAAxB,UAAA;AAAwB,SAAxB;AACA,aAAA,kBAAA,CAAA,IAAA,CAAA,KAAA,EAAoC;AAApC,UAAA;AAAoC,SAApC;AAEH;AAVD,KAAA;;AAYA,cAA2C;AACzC;AACA;AACA,UAAII,MAAM,CAANA,GAAAA,IAAcA,MAAM,CAANA,GAAAA,CAAAA,MAAAA,OAAlB,MAAA,EAAkD;AAChDC,QAAAA,OAAO,CAAPA,GAAAA,CACG,iEAAgE9D,KADnE8D,GAAAA;;AAIA,cAAMC,KAAK,GAAIC,MAAD,IAAY;AACxB,cAAIA,MAAM,KAAV,MAAA,EAAuB;AACrBH,YAAAA,MAAM,CAANA,GAAAA,CAAAA,mBAAAA,CAAAA,KAAAA;AACAL,YAAAA,QAAQ;AAEX;AALD,SAAA;;AAMAK,QAAAA,MAAM,CAANA,GAAAA,CAAAA,MAAAA,CAAAA,KAAAA;AACA;AAEH;AAEDL;;AAAAA,IAAAA,QAAQ;AAGV;AAAA;;;;;;AAIAS,EAAAA,QAAQ,CAAA,KAAA,EAAA,YAAA,EAAsB;AAC5B;AACA;AACA,QAAA,EAAA;;AACA,QAAKC,EAAE,GAAGC,SAAS,CAAnB,UAAA,EAAiC;AAC/B;AACA,UAAID,EAAE,CAAFA,QAAAA,IAAe,KAAA,IAAA,CAAUA,EAAE,CAA/B,aAAmB,CAAnB,EAAgD,OAAOE,OAAO,CAAd,OAAOA,EAAP;AAGlD;AAAA;;;AACA,QAAA,GAAA;;AACA,QAAA,YAAA,EAAkB;AAChBtD,MAAAA,GAAG,GAAHA,KAAAA;AADF,KAAA,MAEO;AACL,gBAA2C;AACzCd,QAAAA,KAAK,GAAGsB,cAAc,CAAtBtB,KAAsB,CAAtBA;AAEA,cAAMqE,GAAG,GACP9D,OAAO,CAAPA,GAAAA,CAAAA,mBAAAA,IAAAA,WAAAA,GAAAA,YAAAA,GADF,KAAA;AAEA,cAAM6C,WAAW,GAAG,CAAA,GAAA,sBAAA,CAAA,OAAA,EAAA,KAAA,EAApB,GAAoB,CAApB;AAEAtC,QAAAA,GAAG,GAAI,GAAE,KAAKC,WAAY,iBAAgBuD,kBAAkB,CAC1D,KAD0D,OAAA,CAE1D,SAAQtD,SAAS,CAAA,WAAA,CAFnBF,EAAAA;AAIH;AAED;;AAAA,WAAO,OAAO,CAAP,GAAA,CACLf,QAAQ,CAARA,aAAAA,CAAwB,aAAYE,WAAY,aAAYa,GAA5Df,IAAAA,IAAAA,EAAAA,GAEI,CACEe,GAAG,IACD+B,UAAU,CAAA,GAAA,EAAA,WAAA,EAGR/B,GAAG,CAAHA,QAAAA,CAAAA,MAAAA,IAAAA,OAAAA,GALN,QAEc,CAFd,EAOEP,SACE,CADFA,YAAAA,IAEE,KAAA,eAAA,CAAA,KAAA,EAAA,IAAA,CAAkCgE,IAAD,IAC/BH,OAAO,CAAPA,GAAAA,CACEG,IAAI,CAAJA,GAAAA,CAAUC,aAAD,IACP,KAAA,QAAA,CAAA,aAAA,EAfT,IAeS,CADFD,CADFH,CADF,CATJ,CAHC,EAAA,IAAA,EAqBL;AACA,UAAM,CAtBD,CAAA,EAuBL;AACA,UAAM,CAxBR,CAAO,CAAP;AA9R4B;;AAAA","sourcesContent":["import mitt from '../next-server/lib/mitt'\nimport { addBasePath, markLoadingError } from '../next-server/lib/router/router'\nimport escapePathDelimiters from '../next-server/lib/router/utils/escape-path-delimiters'\nimport getAssetPathFromRoute from './../next-server/lib/router/utils/get-asset-path-from-route'\nimport { isDynamicRoute } from './../next-server/lib/router/utils/is-dynamic'\nimport { parseRelativeUrl } from './../next-server/lib/router/utils/parse-relative-url'\nimport { searchParamsToUrlQuery } from './../next-server/lib/router/utils/querystring'\nimport { getRouteMatcher } from './../next-server/lib/router/utils/route-matcher'\nimport { getRouteRegex } from './../next-server/lib/router/utils/route-regex'\n\nfunction hasRel(rel, link) {\n  try {\n    link = document.createElement('link')\n    return link.relList.supports(rel)\n  } catch {}\n}\n\nfunction pageLoadError(route) {\n  return markLoadingError(new Error(`Error loading ${route}`))\n}\n\nconst relPrefetch =\n  hasRel('preload') && !hasRel('prefetch')\n    ? // https://caniuse.com/#feat=link-rel-preload\n      // macOS and iOS (Safari does not support prefetch)\n      'preload'\n    : // https://caniuse.com/#feat=link-rel-prefetch\n      // IE 11, Edge 12+, nearly all evergreen\n      'prefetch'\n\nconst hasNoModule = 'noModule' in document.createElement('script')\n\nconst requestIdleCallback =\n  window.requestIdleCallback ||\n  function (cb) {\n    return setTimeout(cb, 1)\n  }\n\n/** @param {string} route */\nfunction normalizeRoute(route) {\n  if (route[0] !== '/') {\n    throw new Error(`Route name should start with a \"/\", got \"${route}\"`)\n  }\n\n  if (route === '/') return route\n  return route.replace(/\\/$/, '')\n}\n\nfunction appendLink(href, rel, as) {\n  return new Promise((res, rej, link) => {\n    link = document.createElement('link')\n    link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN\n    link.href = href\n    link.rel = rel\n    if (as) link.as = as\n\n    link.onload = res\n    link.onerror = rej\n\n    document.head.appendChild(link)\n  })\n}\n\nexport default class PageLoader {\n  constructor(buildId, assetPrefix, initialPage) {\n    this.buildId = buildId\n    this.assetPrefix = assetPrefix\n\n    this.pageCache = {}\n    this.pageRegisterEvents = mitt()\n    this.loadingRoutes = {\n      // By default these 2 pages are being loaded in the initial html\n      '/_app': true,\n    }\n\n    // TODO: get rid of this limitation for rendering the error page\n    if (initialPage !== '/_error') {\n      this.loadingRoutes[initialPage] = true\n    }\n\n    if (process.env.NODE_ENV === 'production') {\n      this.promisedBuildManifest = new Promise((resolve) => {\n        if (window.__BUILD_MANIFEST) {\n          resolve(window.__BUILD_MANIFEST)\n        } else {\n          window.__BUILD_MANIFEST_CB = () => {\n            resolve(window.__BUILD_MANIFEST)\n          }\n        }\n      })\n    }\n    /** @type {Promise<Set<string>>} */\n    this.promisedSsgManifest = new Promise((resolve) => {\n      if (window.__SSG_MANIFEST) {\n        resolve(window.__SSG_MANIFEST)\n      } else {\n        window.__SSG_MANIFEST_CB = () => {\n          resolve(window.__SSG_MANIFEST)\n        }\n      }\n    })\n  }\n\n  // Returns a promise for the dependencies for a particular route\n  getDependencies(route) {\n    return this.promisedBuildManifest.then((m) => {\n      return m[route]\n        ? m[route].map((url) => `${this.assetPrefix}/_next/${encodeURI(url)}`)\n        : this.pageRegisterEvents.emit(route, {\n            error: pageLoadError(route),\n          }) ?? []\n    })\n  }\n\n  /**\n   * @param {string} href the route href (file-system path)\n   * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n   */\n  getDataHref(href, asPath, ssg) {\n    const { pathname: hrefPathname, searchParams, search } = parseRelativeUrl(\n      href\n    )\n    const query = searchParamsToUrlQuery(searchParams)\n    const { pathname: asPathname } = parseRelativeUrl(asPath)\n    const route = normalizeRoute(hrefPathname)\n\n    const getHrefForSlug = (/** @type string */ path) => {\n      const dataRoute = getAssetPathFromRoute(path, '.json')\n      return addBasePath(\n        `/_next/data/${this.buildId}${dataRoute}${ssg ? '' : search}`\n      )\n    }\n\n    let isDynamic = isDynamicRoute(route),\n      interpolatedRoute\n    if (isDynamic) {\n      const dynamicRegex = getRouteRegex(route)\n      const dynamicGroups = dynamicRegex.groups\n      const dynamicMatches =\n        // Try to match the dynamic route against the asPath\n        getRouteMatcher(dynamicRegex)(asPathname) ||\n        // Fall back to reading the values from the href\n        // TODO: should this take priority; also need to change in the router.\n        query\n\n      interpolatedRoute = route\n      if (\n        !Object.keys(dynamicGroups).every((param) => {\n          let value = dynamicMatches[param] || ''\n          const { repeat, optional } = dynamicGroups[param]\n\n          // support single-level catch-all\n          // TODO: more robust handling for user-error (passing `/`)\n          let replaced = `[${repeat ? '...' : ''}${param}]`\n          if (optional) {\n            replaced = `${!value ? '/' : ''}[${replaced}]`\n          }\n          if (repeat && !Array.isArray(value)) value = [value]\n\n          return (\n            (optional || param in dynamicMatches) &&\n            // Interpolate group into data URL if present\n            (interpolatedRoute =\n              interpolatedRoute.replace(\n                replaced,\n                repeat\n                  ? value.map(escapePathDelimiters).join('/')\n                  : escapePathDelimiters(value)\n              ) || '/')\n          )\n        })\n      ) {\n        interpolatedRoute = '' // did not satisfy all requirements\n\n        // n.b. We ignore this error because we handle warning for this case in\n        // development in the `<Link>` component directly.\n      }\n    }\n\n    return isDynamic\n      ? interpolatedRoute && getHrefForSlug(interpolatedRoute)\n      : getHrefForSlug(route)\n  }\n\n  /**\n   * @param {string} href the route href (file-system path)\n   * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n   */\n  prefetchData(href, asPath) {\n    const { pathname: hrefPathname } = parseRelativeUrl(href)\n    const route = normalizeRoute(hrefPathname)\n    return this.promisedSsgManifest.then((s, _dataHref) => {\n      requestIdleCallback(() => {\n        // Check if the route requires a data file\n        s.has(route) &&\n          // Try to generate data href, noop when falsy\n          (_dataHref = this.getDataHref(href, asPath, true)) &&\n          // noop when data has already been prefetched (dedupe)\n          !document.querySelector(\n            `link[rel=\"${relPrefetch}\"][href^=\"${_dataHref}\"]`\n          ) &&\n          // Inject the `<link rel=prefetch>` tag for above computed `href`.\n          appendLink(_dataHref, relPrefetch, 'fetch')\n      })\n    })\n  }\n\n  loadPage(route) {\n    route = normalizeRoute(route)\n\n    return new Promise((resolve, reject) => {\n      // If there's a cached version of the page, let's use it.\n      const cachedPage = this.pageCache[route]\n      if (cachedPage) {\n        const { error, page, mod } = cachedPage\n        error ? reject(error) : resolve({ page, mod })\n        return\n      }\n\n      const fire = ({ error, page, mod }) => {\n        this.pageRegisterEvents.off(route, fire)\n        delete this.loadingRoutes[route]\n\n        if (error) {\n          reject(error)\n        } else {\n          resolve({ page, mod })\n        }\n      }\n\n      // Register a listener to get the page\n      this.pageRegisterEvents.on(route, fire)\n\n      if (!this.loadingRoutes[route]) {\n        this.loadingRoutes[route] = true\n        if (process.env.NODE_ENV === 'production') {\n          this.getDependencies(route).then((deps) => {\n            deps.forEach((d) => {\n              if (\n                d.endsWith('.js') &&\n                !document.querySelector(`script[src^=\"${d}\"]`)\n              ) {\n                this.loadScript(d, route)\n              }\n              if (\n                d.endsWith('.css') &&\n                !document.querySelector(`link[rel=stylesheet][href^=\"${d}\"]`)\n              ) {\n                appendLink(d, 'stylesheet').catch(() => {\n                  // FIXME: handle failure\n                  // Right now, this is needed to prevent an unhandled rejection.\n                })\n              }\n            })\n          })\n        } else {\n          // Development only. In production the page file is part of the build manifest\n          route = normalizeRoute(route)\n          let scriptRoute = getAssetPathFromRoute(route, '.js')\n\n          const url = `${this.assetPrefix}/_next/static/chunks/pages${encodeURI(\n            scriptRoute\n          )}`\n          this.loadScript(url, route)\n        }\n      }\n    })\n  }\n\n  loadScript(url, route) {\n    const script = document.createElement('script')\n    if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n      script.type = 'module'\n    }\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN\n    script.src = url\n    script.onerror = () => {\n      this.pageRegisterEvents.emit(route, { error: pageLoadError(url) })\n    }\n    document.body.appendChild(script)\n  }\n\n  // This method if called by the route code.\n  registerPage(route, regFn) {\n    const register = () => {\n      try {\n        const mod = regFn()\n        const pageData = { page: mod.default || mod, mod }\n        this.pageCache[route] = pageData\n        this.pageRegisterEvents.emit(route, pageData)\n      } catch (error) {\n        this.pageCache[route] = { error }\n        this.pageRegisterEvents.emit(route, { error })\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Wait for webpack to become idle if it's not.\n      // More info: https://github.com/vercel/next.js/pull/1511\n      if (module.hot && module.hot.status() !== 'idle') {\n        console.log(\n          `Waiting for webpack to become \"idle\" to initialize the page: \"${route}\"`\n        )\n\n        const check = (status) => {\n          if (status === 'idle') {\n            module.hot.removeStatusHandler(check)\n            register()\n          }\n        }\n        module.hot.status(check)\n        return\n      }\n    }\n\n    register()\n  }\n\n  /**\n   * @param {string} route\n   * @param {boolean} [isDependency]\n   */\n  prefetch(route, isDependency) {\n    // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n    // License: Apache 2.0\n    let cn\n    if ((cn = navigator.connection)) {\n      // Don't prefetch if using 2G or if Save-Data is enabled.\n      if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve()\n    }\n\n    /** @type {string} */\n    let url\n    if (isDependency) {\n      url = route\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        route = normalizeRoute(route)\n\n        const ext =\n          process.env.__NEXT_MODERN_BUILD && hasNoModule ? '.module.js' : '.js'\n        const scriptRoute = getAssetPathFromRoute(route, ext)\n\n        url = `${this.assetPrefix}/_next/static/${encodeURIComponent(\n          this.buildId\n        )}/pages${encodeURI(scriptRoute)}`\n      }\n    }\n\n    return Promise.all(\n      document.querySelector(`link[rel=\"${relPrefetch}\"][href^=\"${url}\"]`)\n        ? []\n        : [\n            url &&\n              appendLink(\n                url,\n                relPrefetch,\n                url.endsWith('.css') ? 'style' : 'script'\n              ),\n            process.env.NODE_ENV === 'production' &&\n              !isDependency &&\n              this.getDependencies(route).then((urls) =>\n                Promise.all(\n                  urls.map((dependencyUrl) =>\n                    this.prefetch(dependencyUrl, true)\n                  )\n                )\n              ),\n          ]\n    ).then(\n      // do not return any data\n      () => {},\n      // swallow prefetch errors\n      () => {}\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}